---

---

<div
	id="canvas-container"
	class="pointer-events-none fixed inset-0 z-20 transition-opacity duration-200"
>
</div>

<script>
	import * as THREE from "three";
	import { GLTFLoader } from "three/examples/jsm/loaders/GLTFLoader.js";
	import { RoomEnvironment } from "three/examples/jsm/environments/RoomEnvironment.js";

	const container = document.getElementById("canvas-container");

	if (container) {
		// Track visibility state for performance
		let isVisible = true;
		let isIntersecting = true; // IntersectionObserver state
		let animationFrameId: number | null = null;
		let hasUserInteracted = false;
		let isSlammedOut = false;

		// Scene setup
		const scene = new THREE.Scene();

		// Camera
		const camera = new THREE.PerspectiveCamera(
			75,
			window.innerWidth / window.innerHeight,
			0.1,
			1000
		);
		camera.position.z = 5;

		// Renderer - CAP PIXEL RATIO AT 2 FOR PERFORMANCE
		const renderer = new THREE.WebGLRenderer({
			alpha: true,
			antialias: true,
		});
		renderer.setSize(window.innerWidth, window.innerHeight);
		renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // Cap at 2x for performance
		renderer.toneMapping = THREE.ACESFilmicToneMapping;
		renderer.toneMappingExposure = 1.0;
		container.appendChild(renderer.domElement);

		// Environment (Studio Lighting like Sketchfab)
		const pmremGenerator = new THREE.PMREMGenerator(renderer);
		const roomEnv = new RoomEnvironment();
		scene.environment = pmremGenerator.fromScene(roomEnv, 0.04).texture;
		// Dispose PMREMGenerator after use to free GPU memory
		pmremGenerator.dispose();

		// Lights (Subtle helpers, main lighting comes from Environment)
		const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
		directionalLight.position.set(5, 5, 5);
		scene.add(directionalLight);

		const backLight = new THREE.DirectionalLight(0xffffff, 0.5);
		backLight.position.set(-5, -5, -5);
		scene.add(backLight);

		// Model
		let model: THREE.Group;
		const loader = new GLTFLoader();

		loader.load(
			"/cotton_ball.glb",
			(gltf) => {
				model = gltf.scene;

				// Center and scale model
				const box = new THREE.Box3().setFromObject(model);
				const center = box.getCenter(new THREE.Vector3());
				const size = box.getSize(new THREE.Vector3());

				const maxDim = Math.max(size.x, size.y, size.z);
				// Increased scale by ~30% (was 3)
				const scale = 4.0 / maxDim;
				model.scale.setScalar(scale);

				// Center the geometry
				model.position.sub(center.multiplyScalar(scale));

				// Create a group to handle rotation/position separately
				const group = new THREE.Group();
				group.add(model);
				scene.add(group);

				// Assign to global variable for animation
				// Store reference for animation loop
				(window as typeof window & { heroModel?: THREE.Group }).heroModel =
					group;
			},
			undefined,
			(error) => {
				console.error("An error happened loading the model:", error);
			}
		);

		// Mouse interaction with THROTTLING
		let mouseX = 0;
		let mouseY = 0;
		let lastMouseMoveTime = 0;
		const MOUSE_THROTTLE_MS = 16; // ~60fps throttle

		const windowHalfX = window.innerWidth / 2;
		const windowHalfY = window.innerHeight / 2;

		document.addEventListener(
			"mousemove",
			(event) => {
				hasUserInteracted = true;
				const now = performance.now();
				if (now - lastMouseMoveTime < MOUSE_THROTTLE_MS) return;
				lastMouseMoveTime = now;

				mouseX = (event.clientX - windowHalfX) / windowHalfX;
				mouseY = (event.clientY - windowHalfY) / windowHalfY;
			},
			{ passive: true }
		);

		// Track any user interaction
		["scroll", "click", "keydown", "touchstart"].forEach((eventType) => {
			document.addEventListener(
				eventType,
				() => {
					hasUserInteracted = true;
				},
				{ passive: true, once: true }
			);
		});

		// Animation Loop - ONLY RENDER WHEN VISIBLE
		function animate() {
			// Only continue loop if visible
			if (!isVisible) {
				animationFrameId = null;
				return;
			}

			animationFrameId = requestAnimationFrame(animate);

			const group = (window as typeof window & { heroModel?: THREE.Group })
				.heroModel;

			if (group) {
				// 1. Rotation based on mouse (360 spin on Y, tilt on X)
				// mouseX is -1 to 1. Multiplying by Math.PI gives -180 to +180 degrees (360 range).
				const targetRotY = mouseX * Math.PI;
				const targetRotX = mouseY * 0.5; // Keep slight vertical tilt

				// Smoothly interpolate rotation
				group.rotation.y += 0.05 * (targetRotY - group.rotation.y);
				group.rotation.x += 0.05 * (targetRotX - group.rotation.x);

				// 2. Position Movement (Parallax)
				// Increased by 20% (0.5 * 1.2 = 0.6)
				const targetPosX = -mouseX * 0.6;
				const targetPosY = mouseY * 0.6;

				group.position.x += 0.05 * (targetPosX - group.position.x);
				group.position.y += 0.05 * (targetPosY - group.position.y);
			}

			renderer.render(scene, camera);
		}

		// Start/stop animation based on visibility
		function startAnimation() {
			if (animationFrameId === null && isVisible) {
				animate();
			}
		}

		function stopAnimation() {
			if (animationFrameId !== null) {
				cancelAnimationFrame(animationFrameId);
				animationFrameId = null;
			}
		}

		// Centralized visibility check - prevents race conditions
		function checkAndUpdateVisibility() {
			const isTabVisible = !document.hidden;
			const containerVisible = !container.classList.contains("opacity-0");

			// Determine if animation should be running
			const shouldBeVisible =
				isIntersecting && isTabVisible && containerVisible && !isSlammedOut;

			if (shouldBeVisible && !isVisible) {
				isVisible = true;
				startAnimation();
			} else if (!shouldBeVisible && isVisible) {
				isVisible = false;
				stopAnimation();
			}
		}

		// INTERSECTION OBSERVER - The recommended way to detect visibility for Lighthouse
		const observer = new IntersectionObserver(
			(entries) => {
				entries.forEach((entry) => {
					isIntersecting = entry.isIntersecting;
					checkAndUpdateVisibility();
				});
			},
			{
				threshold: 0.1, // Trigger when 10% visible
				rootMargin: "0px",
			}
		);
		observer.observe(container);

		// Initial start
		animate();

		// IDLE TIMEOUT: Stop animation after 5 seconds if no user interaction
		// This helps Lighthouse complete its analysis without being blocked
		const IDLE_TIMEOUT = 5000; // 5 seconds
		let idleTimer: ReturnType<typeof setTimeout> | null = null;

		function startIdleTimer() {
			if (idleTimer) clearTimeout(idleTimer);
			idleTimer = setTimeout(() => {
				if (!hasUserInteracted) {
					isVisible = false;
					stopAnimation();
				}
			}, IDLE_TIMEOUT);
		}

		// Start idle timer on load
		startIdleTimer();

		// Handle Resize with DEBOUNCING
		let resizeTimeout: ReturnType<typeof setTimeout>;
		window.addEventListener(
			"resize",
			() => {
				clearTimeout(resizeTimeout);
				resizeTimeout = setTimeout(() => {
					camera.aspect = window.innerWidth / window.innerHeight;
					camera.updateProjectionMatrix();
					renderer.setSize(window.innerWidth, window.innerHeight);
				}, 100);
			},
			{ passive: true }
		);

		// Handle Theme Changes

		// Handle Slam Events - PAUSE RENDERING WHEN HIDDEN
		window.addEventListener("slam-impact", () => {
			container.classList.add("opacity-0");
			isSlammedOut = true;
			checkAndUpdateVisibility();
		});

		window.addEventListener("slam-reset", () => {
			container.classList.remove("opacity-0");
			isSlammedOut = false;
			hasUserInteracted = true; // User is scrolling, so restart animation
			checkAndUpdateVisibility();
		});

		// Use Page Visibility API to pause when tab is hidden
		document.addEventListener("visibilitychange", () => {
			checkAndUpdateVisibility();
		});

		// Handle View Changes - PAUSE RENDERING WHEN NOT ON HOME VIEW
		window.addEventListener("view-change", (e: Event) => {
			const customEvent = e as CustomEvent;
			const viewId = customEvent.detail;

			if (viewId !== "home") {
				// Navigating away from home - stop animation
				isVisible = false;
				stopAnimation();
			} else {
				hasUserInteracted = true; // User is navigating
				checkAndUpdateVisibility();
			}
		});
	}
</script>
