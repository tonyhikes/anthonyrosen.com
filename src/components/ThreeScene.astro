---

---

<div
	id="canvas-container"
	class="pointer-events-none fixed inset-0 z-20 opacity-0 transition-opacity duration-300"
>
	<canvas id="three-canvas"></canvas>
</div>

<script>
	const container = document.getElementById("canvas-container");
	const canvas = document.getElementById("three-canvas") as HTMLCanvasElement;

	if (!container || !canvas) {
		console.error("ThreeScene: Container or canvas not found!");
	} else {
		// Check for OffscreenCanvas support
		const supportsOffscreen = "transferControlToOffscreen" in canvas;

		if (supportsOffscreen) {
			// --- WEB WORKER PATH (Modern browsers) ---
			const offscreen = canvas.transferControlToOffscreen();

			const worker = new Worker(
				new URL("../workers/three-worker.ts", import.meta.url),
				{ type: "module" }
			);

			// Initialize worker with canvas
			worker.postMessage(
				{
					type: "init",
					data: {
						canvas: offscreen,
						width: window.innerWidth,
						height: window.innerHeight,
					},
				},
				[offscreen]
			);

			// Track state
			let isVisible = true;
			let hasUserInteracted = false;
			let isSlammedOut = false;

			// Handle model loaded
			worker.onmessage = (e) => {
				if (e.data.type === "loaded") {
					container.classList.remove("opacity-0");
					container.classList.add("opacity-100");
				}
			};

			// Mouse tracking
			let lastMouseTime = 0;
			const MOUSE_THROTTLE = 16;
			const halfX = window.innerWidth / 2;
			const halfY = window.innerHeight / 2;

			document.addEventListener(
				"mousemove",
				(e) => {
					hasUserInteracted = true;
					const now = performance.now();
					if (now - lastMouseTime < MOUSE_THROTTLE) return;
					lastMouseTime = now;

					worker.postMessage({
						type: "mouse",
						data: {
							x: (e.clientX - halfX) / halfX,
							y: (e.clientY - halfY) / halfY,
						},
					});
				},
				{ passive: true }
			);

			// Resize
			let resizeTimeout: ReturnType<typeof setTimeout>;
			window.addEventListener(
				"resize",
				() => {
					clearTimeout(resizeTimeout);
					resizeTimeout = setTimeout(() => {
						worker.postMessage({
							type: "resize",
							data: {
								width: window.innerWidth,
								height: window.innerHeight,
							},
						});
					}, 100);
				},
				{ passive: true }
			);

			// Visibility helpers
			function updateWorkerVisibility() {
				const shouldBeVisible =
					isVisible && !isSlammedOut && !document.hidden;
				worker.postMessage({
					type: "visibility",
					data: { visible: shouldBeVisible },
				});
			}

			// Idle timeout for Lighthouse
			setTimeout(() => {
				if (!hasUserInteracted) {
					isVisible = false;
					updateWorkerVisibility();
				}
			}, 5000);

			// Track user interaction
			["scroll", "click", "keydown", "touchstart"].forEach((evt) => {
				document.addEventListener(
					evt,
					() => {
						hasUserInteracted = true;
					},
					{ passive: true, once: true }
				);
			});

			// Events
			window.addEventListener("slam-impact", () => {
				container.classList.remove("opacity-100");
				container.classList.add("opacity-0");
				isSlammedOut = true;
				updateWorkerVisibility();
			});

			window.addEventListener("slam-reset", () => {
				container.classList.remove("opacity-0");
				container.classList.add("opacity-100");
				isSlammedOut = false;
				hasUserInteracted = true;
				updateWorkerVisibility();
			});

			document.addEventListener("visibilitychange", () => {
				updateWorkerVisibility();
			});

			window.addEventListener("view-change", (e: Event) => {
				const viewId = (e as CustomEvent).detail;
				if (viewId !== "home") {
					isVisible = false;
					container.classList.remove("opacity-100");
					container.classList.add("opacity-0");
				} else {
					isVisible = true;
					isSlammedOut = false;
					hasUserInteracted = true;
					container.classList.remove("opacity-0");
					container.classList.add("opacity-100");
				}
				updateWorkerVisibility();
			});
		} else {
			// --- FALLBACK PATH (No OffscreenCanvas support) ---
			// Dynamically import the legacy inline version
			console.log("OffscreenCanvas not supported, using fallback");
			import("./ThreeSceneFallback.ts");
		}
	}
</script>

<style>
	#three-canvas {
		position: absolute;
		top: 0;
		left: 0;
		width: 100%;
		height: 100%;
	}
</style>
