---
---
<div id="canvas-container" class="fixed inset-0 z-20 pointer-events-none transition-opacity duration-200"></div>

<script>
    import * as THREE from 'three';
    import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js';
    import { RoomEnvironment } from 'three/examples/jsm/environments/RoomEnvironment.js';

    const container = document.getElementById('canvas-container');

    if (container) {
        // Scene setup
        const scene = new THREE.Scene();
        
        // Camera
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 5;

        // Renderer
        const renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1.0;
        container.appendChild(renderer.domElement);

        // Environment (Studio Lighting like Sketchfab)
        const pmremGenerator = new THREE.PMREMGenerator(renderer);
        scene.environment = pmremGenerator.fromScene(new RoomEnvironment(), 0.04).texture;

        // Lights (Subtle helpers, main lighting comes from Environment)
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(5, 5, 5);
        scene.add(directionalLight);

        const backLight = new THREE.DirectionalLight(0xffffff, 0.5);
        backLight.position.set(-5, -5, -5);
        scene.add(backLight);

        // Model
        let model: THREE.Group;
        const loader = new GLTFLoader();
        
        loader.load('/cotton_ball.glb', (gltf) => {
            model = gltf.scene;
            
            // Center and scale model
            const box = new THREE.Box3().setFromObject(model);
            const center = box.getCenter(new THREE.Vector3());
            const size = box.getSize(new THREE.Vector3());
            
            const maxDim = Math.max(size.x, size.y, size.z);
            // Increased scale by ~30% (was 3)
            const scale = 4.0 / maxDim; 
            model.scale.setScalar(scale);
            
            // Center the geometry
            model.position.sub(center.multiplyScalar(scale));
            
            // Create a group to handle rotation/position separately
            const group = new THREE.Group();
            group.add(model);
            scene.add(group);
            
            // Assign to global variable for animation
            // Store reference for animation loop
            (window as typeof window & { heroModel?: THREE.Group }).heroModel = group;

        }, undefined, (error) => {
            console.error('An error happened loading the model:', error);
        });

        // Mouse interaction
        let mouseX = 0;
        let mouseY = 0;
        
        const windowHalfX = window.innerWidth / 2;
        const windowHalfY = window.innerHeight / 2;

        document.addEventListener('mousemove', (event) => {
            mouseX = (event.clientX - windowHalfX) / windowHalfX;
            mouseY = (event.clientY - windowHalfY) / windowHalfY;
        });

        // Animation Loop
        function animate() {
            requestAnimationFrame(animate);

            const group = (window as typeof window & { heroModel?: THREE.Group }).heroModel;

            if (group) {
                // 1. Rotation based on mouse (360 spin on Y, tilt on X)
                // mouseX is -1 to 1. Multiplying by Math.PI gives -180 to +180 degrees (360 range).
                const targetRotY = mouseX * Math.PI; 
                const targetRotX = mouseY * 0.5; // Keep slight vertical tilt

                // Smoothly interpolate rotation
                group.rotation.y += 0.05 * (targetRotY - group.rotation.y);
                group.rotation.x += 0.05 * (targetRotX - group.rotation.x);

                // 2. Position Movement (Parallax)
                // Increased by 20% (0.5 * 1.2 = 0.6)
                const targetPosX = -mouseX * 0.6;
                const targetPosY = mouseY * 0.6;

                group.position.x += 0.05 * (targetPosX - group.position.x);
                group.position.y += 0.05 * (targetPosY - group.position.y);
            }

            renderer.render(scene, camera);
        }

        animate();

        // Handle Resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Handle Theme Changes
        window.addEventListener('theme-changed', (event: Event) => {
            const customEvent = event as CustomEvent<{ theme: string }>;
            const isDark = customEvent.detail.theme === 'dark';
        });

        // Handle Slam Events
        window.addEventListener('slam-impact', () => {
            container.classList.add('opacity-0');
        });

        window.addEventListener('slam-reset', () => {
            container.classList.remove('opacity-0');
        });
    }

</script>
